(; Base of the encoding ;)

Prop : Type.
injective Prf : Prop -> Type.
Set : Type.
injective El : Set -> Type.


(; Higher order ;)

o : Set.
[ ] El o --> Prop.
fun : Set -> Set -> Set.
[x,y] El (fun x y) --> El x -> El y.


(; Connectives and quantifiers ;)

imp : Prop -> Prop -> Prop.
and : Prop -> Prop -> Prop.
or : Prop -> Prop -> Prop.
top : Prop.
bot : Prop.
all : a : Set -> (El a -> Prop) -> Prop.
ex : a : Set -> (El a -> Prop) -> Prop.
not : Prop -> Prop.
def equiv := p : Prop => q : Prop => and (imp p q) (imp q p).


(; Natural deduction rules ;)

def imp_i : p : Prop -> q : Prop -> (Prf p -> Prf q) -> Prf (imp p q).
def imp_e : p : Prop -> q : Prop -> Prf (imp p q) -> Prf p -> Prf q.

def and_i : p : Prop -> q : Prop -> Prf p -> Prf q -> Prf (and p q).
def and_e_l : p : Prop -> q : Prop -> Prf (and p q) -> Prf p.
def and_e_r : p : Prop -> q : Prop -> Prf (and p q) -> Prf q.

def or_i_l : p : Prop -> Prf p -> q : Prop -> Prf (or p q).
def or_i_r : q : Prop -> Prf q -> p : Prop -> Prf (or p q).
def or_e : p : Prop -> q : Prop -> Prf (or p q) -> r : Prop -> (Prf p -> Prf r) -> (Prf q -> Prf r) -> Prf r.

def neg_i : p : Prop -> (Prf p -> Prf bot) -> Prf (not p).
def neg_e : p : Prop -> Prf (not p) -> Prf p -> Prf bot.

def top_i : Prf top.
def bot_e : Prf bot -> p : Prop -> Prf p.

def all_i : a : Set -> p : (El a -> Prop) -> (x : El a -> Prf (p x)) -> Prf (all a p).
def all_e : a : Set -> p : (El a -> Prop) -> Prf (all a p) -> x : El a -> Prf (p x).

def ex_i : a : Set -> p : (El a -> Prop) -> t : El a -> Prf (p t) -> Prf (ex a p).
def ex_e : a : Set -> p : (El a -> Prop) -> Prf (ex a p) -> r : Prop -> (x : El a -> Prf (p x) -> Prf r) -> Prf r.

def excluded_middle : p : Prop -> Prf (or p (not p)).


(; Some results about double negations ;)

thm prop_double_neg : p : Prop -> Prf (imp p (not (not p))) 
:= p => imp_i p (not (not p)) (pP => neg_i (not p) (pNP => neg_e p pNP pP)).

thm prop_neg_imp : p : Prop -> q : Prop -> Prf (imp (imp p q) (imp (not q) (not p)))
:= p => q => imp_i (imp p q) (imp (not q) (not p)) 
    (pPQ => imp_i (not q) (not p) (pNQ => neg_i p (pP => neg_e q pNQ (imp_e p q pPQ pP)))).

thm prop_neg_imp1 : p : Prop -> q : Prop -> Prf (imp (imp (not (not p)) (not (not q))) (not (not (imp p q))))
:= p => q => 
    imp_i (imp (not (not p)) (not (not q))) (not (not (imp p q))) 
        (pPQ => neg_i (not (imp p q)) 
            (pNPQ => neg_e (imp p q) pNPQ 
                (imp_i p q 
                    (pP => bot_e 
                        (neg_e (not q) 
                            (imp_e (not (not p)) (not (not q)) pPQ (imp_e p (not (not p)) (prop_double_neg p) pP)) 
                            (neg_i q (pQ => neg_e (imp p q) pNPQ (imp_i p q (_ => pQ)))))
                        q)))).

thm prop_neg_imp2 : p : Prop -> q : Prop -> Prf (imp (not (not (imp p q))) (imp (not (not p)) (not (not q))))
:= p => q => 
    imp_i (not (not (imp p q))) (imp (not (not p)) (not (not q))) 
        (pNNPQ => imp_i (not (not p)) (not (not q))
            (pNNP => neg_i (not q) 
                (pNQ => neg_e (not (imp p q)) pNNPQ
                    (neg_i (imp p q) (pPQ => neg_e (not p) pNNP (neg_i p (pP => neg_e q pNQ (imp_e p q pPQ pP)))))))).

thm prop_neg_and1 : p : Prop -> q : Prop -> Prf (imp (and (not (not p)) (not (not q))) (not (not (and p q))))
:= p => q => imp_i (and (not (not p)) (not (not q))) (not (not (and p q)))
    (pNNPQ => neg_i (not (and p q)) 
        (pNPQ => neg_e (not q)
            (and_e_r (not (not p)) (not (not q)) pNNPQ)
            (neg_i q (pQ => neg_e (not p) 
                (and_e_l (not (not p)) (not (not q)) pNNPQ)
                (neg_i p (pP => neg_e (and p q) pNPQ (and_i p q pP pQ))))))).

thm prop_neg_and2 : p : Prop -> q : Prop -> Prf (imp (not (not (and p q))) (and (not (not p)) (not (not q))))
:= p => q => imp_i (not (not (and p q))) (and (not (not p)) (not (not q))) 
    (pNNPQ => and_i (not (not p)) (not (not q))
        (neg_i (not p) 
            (pNP => neg_e (not (and p q)) pNNPQ
                (neg_i (and p q) (pPQ => neg_e p pNP (and_e_l p q pPQ)))))
        (neg_i (not q) 
            (pNQ => neg_e (not (and p q)) pNNPQ
                (neg_i (and p q) (pPQ => neg_e q pNQ (and_e_r p q pPQ)))))).

thm prop_neg_or1 : p : Prop -> q : Prop -> Prf (imp (not (or p q)) (and (not p) (not q)))
:= p => q => imp_i (not (or p q)) (and (not p) (not q)) 
    (pNPQ => and_i (not p) (not q)
        (neg_i p (pP => neg_e (or p q) pNPQ (or_i_l p pP q)))
        (neg_i q (pQ => neg_e (or p q) pNPQ (or_i_r q pQ p)))).

thm prop_neg_or2 : p : Prop -> q : Prop -> Prf (imp (and (not p) (not q)) (not (or p q)))
:= p => q => imp_i (and (not p) (not q)) (not (or p q)) 
    (pNPQ => neg_i (or p q)
        (pPQ => or_e p q pPQ bot
            (pP => neg_e p (and_e_l (not p) (not q) pNPQ) pP)
            (pQ => neg_e q (and_e_r (not p) (not q) pNPQ) pQ))).

thm prop_neg_fa : a : Set -> p : (El a -> Prop) -> Prf (imp (not (not (all a p))) (all a (x : (El a) => (not (not (p x))))))
:= a => p => imp_i (not (not (all a p))) (all a (x => not (not (p x)))) 
    (pNNP => all_i a (x => not (not (p x))) 
        (x => neg_i (not (p x)) 
            (pNP => neg_e (not (all a p)) pNNP
                (neg_i (all a p) 
                    (pP => neg_e (p x) pNP (all_e a p pP x)))))).

thm prop_neg_ex1 : a : Set -> p : (El a -> Prop) -> Prf (imp (not (ex a p)) (all a (x : (El a) => (not (p x)))))
:=  a => p => imp_i (not (ex a p)) (all a (x => not (p x))) 
    (pNP => all_i a (x => not (p x)) 
        (x => neg_i (p x) 
            (pP => neg_e (ex a p) pNP (ex_i a p x pP)))).

thm prop_neg_ex2 : a : Set -> p : (El a -> Prop) -> Prf (imp (all a (x : (El a) => (not (p x)))) (not (ex a p)))
:= a => p => 
    imp_i (all a (x => not (p x))) (not (ex a p))
        (pNP => neg_i (ex a p) 
            (pP => ex_e a p pP bot 
                (t => pPt => neg_e (p t) (all_e a (x => not (p x)) pNP t) pPt))).

thm prop_triple_neg : p : Prop -> Prf (imp (not (not (not p))) (not p))
:= p => imp_i (not (not (not p))) (not p) 
    (pNNNP => neg_i p (pP => neg_e (not (not p)) pNNNP (imp_e p (not (not p)) (prop_double_neg p) pP))).

thm prop_neg_bot : Prf (imp (not (not bot)) bot)
:= imp_i (not (not bot)) bot (pB => neg_e (not bot) pB (neg_i bot (pN => pN))).

thm prop_neg_top : Prf (imp (not (not top)) top)
:= imp_i (not (not top)) top (_ => top_i).


(; Kuroda's translation ;)

def Prf_c : Prop -> Type.
[p] Prf_c p --> Prf (not (not p)).
def all_c : a : Set -> (El a -> Prop) -> Prop.
[a, p] all_c a p --> all a (x : (El a) => (not (not (p x)))).

(; To be transformed into theorems later ;)
def imp_i_c : p : Prop -> q : Prop -> (Prf_c p -> Prf_c q) -> Prf_c (imp p q).
def imp_e_c : p : Prop -> q : Prop -> Prf_c (imp p q) -> Prf_c p -> Prf_c q.
def and_i_c : p : Prop -> q : Prop -> Prf_c p -> Prf_c q -> Prf_c (or p q).
def and_e_l_c : p : Prop -> q : Prop -> Prf_c (or p q) -> Prf_c p.
def and_e_r_c : p : Prop -> q : Prop -> Prf_c (or p q) -> Prf_c q.
def or_i_l_c : p : Prop -> Prf_c p -> q : Prop -> Prf_c (or p q).
def or_i_r_c : q : Prop -> Prf_c q -> p : Prop -> Prf_c (or p q).
def or_e_c : p : Prop -> q : Prop -> Prf_c (or p q) -> r : Prop -> (Prf_c p -> Prf_c r) -> (Prf_c q -> Prf_c r) -> Prf_c r.
def neg_i_c : p : Prop -> (Prf_c p -> Prf_c bot) -> Prf_c (not p).
def neg_e_c : p : Prop -> Prf_c (not p) -> Prf_c p -> Prf_c bot.
def top_i_c : Prf_c top.
def bot_e_c : Prf_c bot -> p : Prop -> Prf_c p.
def all_i_c : a : Set -> p : (El a -> Prop) -> (x : (El a) -> Prf_c (p x)) -> Prf_c (all_c a (x : (El a) => (p x))).
def all_e_c : a : Set -> p : (El a -> Prop) -> Prf_c (all_c a (x : (El a) => (p x))) -> x : (El a) -> Prf_c (p x).
def ex_i_c : a : Set -> p : (El a -> Prop) -> t : (El a) -> Prf_c (p t) -> Prf_c (ex a p).
def ex_e_c : a : Set -> p : (El a -> Prop) -> Prf_c (ex a p) -> r : Prop -> (x : (El a) -> Prf_c (p x) -> Prf_c r) -> Prf_c r.
def excluded_middle_c : p : Prop -> Prf_c (or p (not p)).

